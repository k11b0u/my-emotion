<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Emotion Record (end-of-track switch)</title>
<style>
  :root { color-scheme: light dark; }
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:960px;margin:20px auto;padding:0 12px}
  .card{border:1px solid #333;border-radius:14px;padding:16px;margin:14px 0;box-shadow:0 1px 4px rgba(0,0,0,.06);background:#121212}
  button{padding:10px 14px;border-radius:10px;border:1px solid #444;background:#1e1e1e;cursor:pointer;color:#eee}
  button:hover:not(:disabled){background:#2a2a2a} button:disabled{color:#9aa;border-color:#444;background:#2a2a2a;cursor:not-allowed}
  input,textarea,select{width:100%;padding:8px;border:1px solid #444;border-radius:10px;background:#1a1a1a;color:#eee}
  .muted{color:#b0b0b0} .row{display:flex;gap:10px;flex-wrap:wrap} .row>*{flex:1}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  #log{white-space:pre-wrap;height:180px;overflow:auto;background:#0f0f0f;color:#e6e6e6;border:1px solid #333;border-radius:8px;padding:8px}
  .hint{font-size:12px;color:#aaa}
</style>
</head>
<body>
<h1>Emotion Record</h1>

<!-- 状態 -->
<div class="card">
  <h2>状態</h2>
  <p>BLE: <span id="bleState">未接続</span> ／ Spotify: <span id="spState">未ログイン</span></p>

  <div class="row" style="margin-top:6px">
    <button id="btnBle">心拍センサー接続（COOSPO）</button>
    <button id="btnSp">Spotifyログイン</button>
    <button id="btnStart">セッション開始</button>
    <button id="btnStop" disabled>セッション終了</button>
  </div>

  <div class="row" style="margin-top:10px">
    <div>
      <label>本日の条件（解析用ラベル）</label>
      <select id="cond">
        <option value="NONE">NONE（介入なし）</option>
        <option value="SCENT">SCENT（香りのみ）</option>
        <option value="MUSIC" selected>MUSIC（音楽のみ）</option>
        <option value="BOTH">BOTH（複合）</option>
      </select>
      <div class="hint">※ ここは解析用の記録ラベル。介入ON/OFFは自動切替ロジックで行います。</div>
    </div>
    <div>
      <label>参加者ID（pid）</label>
      <input id="pid" placeholder="hiro" value="hiro"/>
    </div>
    <div>
      <label>鎮静時の方針</label>
      <select id="calmPolicy">
        <option value="silence">無音（停止）</option>
        <option value="music" selected>鎮静プレイリストで維持</option>
      </select>
      <div class="hint">※ 研究設計に合わせて切替可</div>
    </div>
  </div>
</div>

<!-- Spotify デバイス選択 -->
<div class="card">
  <h2>Spotify デバイス</h2>
  <div class="row">
    <div>
      <label>デバイス一覧</label>
      <select id="devices"></select>
    </div>
    <div style="flex:0 0 200px;display:flex;gap:8px;align-items:flex-end">
      <button id="btnRefreshDev">一覧更新</button>
      <button id="btnUseDev">このデバイスを使う</button>
    </div>
  </div>
  <div class="row" style="margin-top:8px">
    <button id="btnTestPlay">▶ テスト再生</button>
    <button id="btnPause">⏸ 一時停止</button>
  </div>
  <p class="muted mono" id="devInfo">device: -</p>
  <p class="hint">※ Spotifyアプリ側で一度どれかを再生→停止するとデバイスが現れやすいです。</p>
</div>

<!-- ログ -->
<div class="card">
  <h2>ログ</h2>
  <pre id="log" class="mono"></pre>
  <div class="row">
    <button id="btnCsv" disabled>CSVダウンロード</button>
    <button id="btnClear">画面ログをクリア</button>
  </div>
</div>

<!-- アンケート -->
<div class="card">
  <h2>就寝前アンケート</h2>
  <div class="row">
    <div><label>いまの気分（0〜10）</label><input type="number" id="mood" min="0" max="10"/></div>
    <div><label>リラックス度（0〜10）</label><input type="number" id="relax" min="0" max="10"/></div>
  </div>
  <label>メモ（任意）</label><textarea id="notes" rows="2" placeholder="寝つき・出来事など"></textarea>
  <button id="btnNote">追加</button>
</div>

<script>
/* ===================== 設定（ここだけ置換） ===================== */
// ① あなたの Spotify Client ID
const SPOTIFY_CLIENT_ID = "7838a0cf003644ae8b5f3f75b9eb534e"; // ←★置換★

// ② あなたの公開URL（Spotifyアプリにも同じURIを登録）
const REDIRECT_URI = "https://my-emotion2025.vercel.app/"; // ←★置換★

// 必要スコープ
const SCOPES = [
  "user-read-playback-state",
  "user-modify-playback-state",
  "playlist-read-private",
  "playlist-read-collaborative",
  "user-read-currently-playing"
].join(" ");

// ③ 実験で使うプレイリスト
const PLAYLIST_TENSION_TO_CALM = "spotify:playlist:6lEP2HI9ecRpSoHQNRTok7"; // 緊張→鎮静
const PLAYLIST_DEPRESS_TO_LIFT = "spotify:playlist:0TFRed2ZNnofW4uGxjytvT"; // 落ち込み→鎮静
const PLAYLIST_CALM_MAINTAIN   = "spotify:playlist:2m9HoHfpO0tk5eky1fopVu"; // 鎮静維持

/* ===================== グローバル状態 ===================== */
const logEl = document.getElementById("log");
const bleStateEl = document.getElementById("bleState");
const spStateEl  = document.getElementById("spState");
const devInfoEl  = document.getElementById("devInfo");
const devicesSel = document.getElementById("devices");
const btnCsv     = document.getElementById("btnCsv");
const btnClear   = document.getElementById("btnClear");
const calmPolicySel = document.getElementById("calmPolicy");
const condSel = document.getElementById("cond");

let spotifyAccessToken = null;
let selectedDeviceId = null;

let hr = null, rrList = [];         // RR(秒)
let timer = null;
let sessionId = Math.random().toString(36).slice(2,10);
let csvRows = [[]];

// 個人ベースライン
let prevHR=null, prevRMSSD=null;
let hr_base = 70, sd_hr = 8;
let rmssd_base = 0.04, sd_rmssd = 0.015;
const EWMA = 0.05;

// 自動切替・曲終端待ち
let lastEmotion = null;                 // "tension"|"calm"|"depress"|null
let switchTimer = null;
let switchTargetEmotion = null;
let switchTargetUri = null;
const SWITCH_AT_REMAIN_MS = 3500;       // 曲の残りがこの値以下で切替
const POLL_EVERY_MS = 1200;             // ポーリング間隔
const ENABLE_AUTOSWITCH = true;         // 自動切替を有効にする
function CALM_POLICY(){ return calmPolicySel.value; } // "silence" or "music"

/* ===================== ユーティリティ ===================== */
function log(s){ logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }
function clearLog(){ logEl.textContent = ""; }
function isoNow(){ return new Date().toISOString().replace("T"," ").slice(0,19); }

function calcRMSSD(rrs){
  if(rrs.length < 3) return null;
  let sum = 0, n = 0;
  for(let i=1;i<rrs.length;i++){ const d = rrs[i]-rrs[i-1]; sum += d*d; n++; }
  return Math.sqrt(sum/n); // 秒
}

function makeHeader(){
  csvRows = [[
    "timestamp","datetime","pid","day","session_id","block","condition",
    "hr","rmssd","rmssd_ms","z_hr","z_rmssd","d_hr","d_rmssd",
    "emotion",
    "track_id","track_name","artists","context_uri",
    "hr_base","rmssd_base","sd_hr","sd_rmssd",
    "is_playing","exercise","valid_for_rank",
    "mood","relax","note"
  ]];
}

/* ===================== Web Bluetooth (HR 0x180D) ===================== */
async function connectBLE(){
  try{
    log("BLE: デバイス選択…");
    const dev = await navigator.bluetooth.requestDevice({
      filters:[{services:["heart_rate"]}], optionalServices:["heart_rate"]
    });
    const server = await dev.gatt.connect();
    const service = await server.getPrimaryService("heart_rate");
    const ch = await service.getCharacteristic("heart_rate_measurement");
    await ch.startNotifications();
    ch.addEventListener("characteristicvaluechanged", (e)=>{
      const v = e.target.value;
      const flags = v.getUint8(0);
      const hrValue = (flags & 0x01) ? v.getUint16(1,true) : v.getUint8(1);
      hr = hrValue;
      let idx = (flags & 0x01) ? 3 : 2;
      const rrLocal = [];
      while(idx+1 < v.byteLength){
        const rr = v.getUint16(idx,true)/1024.0; // 秒
        rrLocal.push(rr); idx += 2;
      }
      if(rrLocal.length){
        rrList.push(...rrLocal);
        if(rrList.length>60) rrList = rrList.slice(-60);
      }
      bleStateEl.textContent = `接続中（HR=${hr})`;
    });
    bleStateEl.textContent = "接続完了";
    log("BLE: 接続しました");
  }catch(err){
    log("BLE error: "+err.message);
    bleStateEl.textContent = "未接続";
  }
}

/* ===================== Spotify 認証 & API ===================== */
function base64url(bytes){
  return btoa(String.fromCharCode(...new Uint8Array(bytes)))
    .replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
}
async function pkce(){
  const ver = base64url(crypto.getRandomValues(new Uint8Array(32)));
  const enc = new TextEncoder().encode(ver);
  const digest = await crypto.subtle.digest("SHA-256", enc);
  const chal = base64url(digest);
  sessionStorage.setItem("pkce_verifier", ver);
  return chal;
}
async function loginSpotify(){
  const params = new URLSearchParams(location.search);
  const code = params.get("code");
  if(!code){
    const challenge = await pkce();
    const url = "https://accounts.spotify.com/authorize?" + new URLSearchParams({
      client_id: SPOTIFY_CLIENT_ID,
      response_type: "code",
      redirect_uri: REDIRECT_URI,
      scope: SCOPES,
      code_challenge_method: "S256",
      code_challenge: challenge
    });
    location.href = url;
    return;
  }
  const ver = sessionStorage.getItem("pkce_verifier");
  const body = new URLSearchParams({
    grant_type:"authorization_code", code,
    redirect_uri:REDIRECT_URI, client_id:SPOTIFY_CLIENT_ID, code_verifier:ver
  });
  const r = await fetch("https://accounts.spotify.com/api/token", {
    method:"POST", headers:{ "Content-Type":"application/x-www-form-urlencoded" }, body
  });
  const tok = await r.json();
  if(tok.access_token){
    spotifyAccessToken = tok.access_token;
    spStateEl.textContent = "ログイン済み";
    log("Spotify: ログイン完了");
    history.replaceState({}, "", REDIRECT_URI);
    await refreshDevices();
  }else{
    log("Spotify トークン取得失敗: "+JSON.stringify(tok));
  }
}
async function spRequest(method, url, body, params){
  if(!spotifyAccessToken) throw new Error("no token");
  const qs = params ? ("?" + new URLSearchParams(params)) : "";
  return fetch(url + qs, {
    method,
    headers:{ "Authorization":"Bearer "+spotifyAccessToken, "Content-Type":"application/json" },
    body: body? JSON.stringify(body): undefined
  });
}
async function getDevices(){
  try{
    const r = await spRequest("GET","https://api.spotify.com/v1/me/player/devices");
    const j = await r.json();
    return j.devices || [];
  }catch(_){ return []; }
}
async function refreshDevices(){
  const devs = await getDevices();
  devicesSel.innerHTML = "";
  devs.forEach(d=>{
    const opt = document.createElement("option");
    opt.value = d.id;
    opt.textContent = `${d.name}  [${d.type}]  ${d.is_active?"(active)":""}`;
    devicesSel.appendChild(opt);
  });
  if(devs.length===0){
    const opt = document.createElement("option");
    opt.value=""; opt.textContent="（見つかりません）";
    devicesSel.appendChild(opt);
  }
}
async function transferPlayback(deviceId, play){
  try{
    const r = await spRequest("PUT","https://api.spotify.com/v1/me/player",{device_ids:[deviceId], play: !!play});
    return r.status===204;
  }catch(_){ return false; }
}
async function ensureShuffleOn(deviceId){
  try{ await spRequest("PUT","https://api.spotify.com/v1/me/player/shuffle", null, {state:"true", device_id:deviceId}); }catch(_){}
}
async function playPlaylist(contextUri){
  if(!selectedDeviceId){ log("playPlaylist: デバイス未選択"); return; }
  await ensureShuffleOn(selectedDeviceId);
  const r = await spRequest("PUT","https://api.spotify.com/v1/me/player/play",
    { context_uri: contextUri, position_ms:0, offset:{position:0} },
    { device_id: selectedDeviceId }
  );
  if(!r.ok){ log("play err: "+(await r.text()).slice(0,200)); }
}
async function pausePlayback(){
  if(!selectedDeviceId){ log("pause: デバイス未選択"); return; }
  try{ await spRequest("PUT","https://api.spotify.com/v1/me/player/pause", null, {device_id:selectedDeviceId}); }catch(_){}
}
async function getCurrentPlaying(){
  try{
    const r = await spRequest("GET","https://api.spotify.com/v1/me/player/currently-playing");
    if(r.status===204) return null;
    return await r.json();
  }catch(_){ return null; }
}
function extractTrackInfo(j){
  try{
    if(!j || !j.is_playing || !j.item) return {track_id:"",track_name:"",artists:"",context_uri:""};
    const item = j.item;
    const artists = (item.artists||[]).map(a=>a.name).join(", ");
    const ctx = (j.context && j.context.uri) ? j.context.uri : "";
    return { track_id:item.id||"", track_name:item.name||"", artists, context_uri: ctx };
  }catch(_){ return {track_id:"",track_name:"",artists:"",context_uri:""}; }
}

/* ===================== 感情ロジック ===================== */
function decideEmotion(hrValue, rmssd){
  // 研究に合わせてしきい値は後で微調整
  if(rmssd==null) return "unknown";
  if(rmssd < 0.025) return "tension";
  if(rmssd > 0.060) return "calm";
  // 落ち込み検知が必要なら zスコア等を拡張（簡易では unknown 扱い）
  return "unknown";
}
function targetContextForEmotion(emotion){
  if(emotion === "tension") return PLAYLIST_TENSION_TO_CALM;
  if(emotion === "depress") return PLAYLIST_DEPRESS_TO_LIFT;
  if(emotion === "calm")    return (CALM_POLICY()==="music") ? PLAYLIST_CALM_MAINTAIN : null;
  return null;
}
function inferEmotionFromContext(ctx){
  if(!ctx) return null;
  if(ctx === PLAYLIST_TENSION_TO_CALM) return "tension";
  if(ctx === PLAYLIST_DEPRESS_TO_LIFT) return "depress";
  if(ctx === PLAYLIST_CALM_MAINTAIN)   return "calm";
  return null;
}

/* ====== 曲終端でのみ切替するスケジューラ ====== */
function scheduleSwitchToEmotion(emotion){
  if(lastEmotion && lastEmotion === emotion) return; // 同じなら何もしない
  switchTargetEmotion = emotion;
  switchTargetUri = targetContextForEmotion(emotion);
  if(!switchTimer){ switchTimer = setInterval(_switchTick, POLL_EVERY_MS); }
}
async function _switchTick(){
  try{
    const j = await getCurrentPlaying();
    if(!j || !j.item){ await _executeSwitchNow(); return; }

    const progress = j.progress_ms || 0;
    const duration = j.item.duration_ms || 0;
    const remain   = Math.max(0, duration - progress);
    const currentCtx = (j.context && j.context.uri) ? j.context.uri : "";

    if(switchTargetUri && currentCtx === switchTargetUri){
      lastEmotion = switchTargetEmotion;
      _clearSwitch();
      return;
    }
    if(remain <= SWITCH_AT_REMAIN_MS){
      await _executeSwitchNow();
    }
  }catch(_){ /* 次ループで再挑戦 */ }
}
async function _executeSwitchNow(){
  if(!switchTargetEmotion){ _clearSwitch(); return; }
  if(switchTargetEmotion === "calm" && CALM_POLICY()==="silence"){
    await pausePlayback();
  }else if(switchTargetUri){
    await playPlaylist(switchTargetUri);
  }
  lastEmotion = switchTargetEmotion;
  _clearSwitch();
}
function _clearSwitch(){
  if(switchTimer){ clearInterval(switchTimer); switchTimer = null; }
  switchTargetEmotion = null;
  switchTargetUri = null;
}

async function maybeAutoSwitch(emotion, condition){
  if(!ENABLE_AUTOSWITCH) return;
  if(!(condition==="MUSIC" || condition==="BOTH")) return;
  if(!selectedDeviceId){ log("auto: 再生デバイス未選択"); return; }
  if(lastEmotion && lastEmotion === emotion) return; // 同じなら維持
  scheduleSwitchToEmotion(emotion); // 予約のみ（実行は曲終端）
}

/* ===================== セッション制御 ===================== */
async function startSession(){
  if(!spotifyAccessToken) log("※ Spotifyログインしてね（制御なしでも記録は可能）");

  // デバイス未選択なら選択
  if(!selectedDeviceId){
    await refreshDevices();
    const v = devicesSel.value;
    if(v){ selectedDeviceId = v; devInfoEl.textContent = "device: " + v; }
  }
  if(selectedDeviceId){
    await transferPlayback(selectedDeviceId, true);
  }

  // 現在のコンテキストから lastEmotion を初期化
  try{
    const cur = await getCurrentPlaying();
    const ctx = cur && cur.context ? cur.context.uri : "";
    lastEmotion = inferEmotionFromContext(ctx) || null;
  }catch(_){}

  document.getElementById("btnStart").disabled = true;
  document.getElementById("btnStop").disabled = false;
  btnCsv.disabled = true;
  makeHeader();
  sessionId = Math.random().toString(36).slice(2,10);
  log("セッション開始: "+sessionId);

  timer = setInterval(async ()=>{
    const now = Date.now();
    const dayStr = new Date().toLocaleDateString("ja-JP");
    const pid = (document.getElementById("pid").value||"").trim() || "pid";
    const condition = condSel.value; // NONE/SCENT/MUSIC/BOTH

    const rmssd = calcRMSSD(rrList.slice(-10));
    const rmssd_ms = rmssd!=null ? Math.round(rmssd*1000) : "";
    const z_hr = (hr!=null) ? (hr-hr_base)/sd_hr : "";
    const z_rmssd = (rmssd!=null) ? (rmssd-rmssd_base)/sd_rmssd : "";
    const d_hr = (prevHR!=null && hr!=null) ? (hr-prevHR) : "";
    const d_rmssd = (prevRMSSD!=null && rmssd!=null) ? (rmssd-prevRMSSD) : "";

    let playing = false, track = {track_id:"",track_name:"",artists:"",context_uri:""};
    if(spotifyAccessToken){
      const j = await getCurrentPlaying();
      playing = !!(j && j.is_playing);
      track = extractTrackInfo(j);
    }

    // 簡易：運動除外
    const exercise = (hr!=null && hr_base!=null && hr >= hr_base+25) ? 1 : 0;

    // ランキング対象（介入なし×再生中×運動なし）
    const valid_for_rank = (condition==="NONE" && playing && !exercise) ? 1 : 0;

    // 感情推定
    const emotion = decideEmotion(hr, rmssd); // "tension"|"calm"|"unknown"

    // ログ1行
    csvRows.push([
      now, isoNow(), pid, dayStr, sessionId, "block1", condition,
      hr??"", rmssd??"", rmssd_ms, z_hr===""?"":z_hr, z_rmssd===""?"":z_rmssd, d_hr, d_rmssd,
      emotion,
      track.track_id, track.track_name, track.artists, track.context_uri,
      hr_base, rmssd_base, sd_hr, sd_rmssd,
      playing?1:0, exercise, valid_for_rank,
      "", "", ""
    ]);

    // 自動切替（曲終端で反映・同じ感情は維持）
    if(emotion==="tension" || emotion==="calm" || emotion==="depress"){
      await maybeAutoSwitch(emotion, condition);
    }

    // ベースラインの緩やかな更新（“ほぼ中立”）
    if(rmssd!=null && hr!=null && Math.abs(z_hr)<0.5 && z_rmssd>-0.3){
      hr_base    = (1-EWMA)*hr_base    + EWMA*hr;
      rmssd_base = (1-EWMA)*rmssd_base + EWMA*rmssd;
      sd_hr      = (1-EWMA)*sd_hr      + EWMA*Math.abs(hr-hr_base);
      sd_rmssd   = (1-EWMA)*sd_rmssd   + EWMA*Math.abs(rmssd-rmssd_base);
    }

    prevHR = hr; prevRMSSD = rmssd;
  }, 60*1000); // 1分おき
}

function stopSession(){
  clearInterval(timer); timer=null;
  document.getElementById("btnStart").disabled = false;
  document.getElementById("btnStop").disabled = true;
  btnCsv.disabled = false;
  log("セッション終了");
  // 切替予約が残っていたら解放
  if(switchTimer){ clearInterval(switchTimer); switchTimer=null; }
  switchTargetEmotion = null; switchTargetUri = null;
}

// アンケ：直近行末尾に追記
document.getElementById("btnNote").onclick = ()=>{
  const mood = document.getElementById("mood").value||"";
  const relax = document.getElementById("relax").value||"";
  const notes = document.getElementById("notes").value||"";
  if(csvRows.length>1){
    const last = csvRows[csvRows.length-1];
    last[last.length-3] = mood;
    last[last.length-2] = relax;
    last[last.length-1] = notes;
  }else{
    makeHeader();
    const pid = (document.getElementById("pid").value||"pid");
    csvRows.push([Date.now(), isoNow(), pid, new Date().toLocaleDateString("ja-JP"), sessionId, "block1", condSel.value,
      "","","","","","","",
      "",
      "","","","",
      hr_base, rmssd_base, sd_hr, sd_rmssd,
      0,0,0,
      mood, relax, notes
    ]);
  }
  log("アンケ追加");
};

// CSV保存
btnCsv.onclick = ()=>{
  const blob = new Blob([csvRows.map(r=>r.join(",")).join("\n")], {type:"text/csv"});
  const dayStr = new Date().toISOString().slice(0,10);
  const a = Object.assign(document.createElement("a"), {
    href: URL.createObjectURL(blob),
    download: `emotion_log_${dayStr}_${sessionId}.csv`
  });
  a.click(); URL.revokeObjectURL(a.href);
};

// UIイベント
document.getElementById("btnBle").onclick = connectBLE;
document.getElementById("btnSp").onclick = loginSpotify;
document.getElementById("btnStart").onclick = startSession;
document.getElementById("btnStop").onclick = stopSession;
btnClear.onclick = clearLog;

// デバイス操作UI
document.getElementById("btnRefreshDev").onclick = refreshDevices;
document.getElementById("btnUseDev").onclick = async ()=>{
  const v = devicesSel.value;
  if(!v){ log("デバイスを選んでください"); return; }
  selectedDeviceId = v;
  devInfoEl.textContent = "device: " + v;
  await transferPlayback(selectedDeviceId, true);
  log("デバイス固定 & 転送しました");
};
document.getElementById("btnTestPlay").onclick = async ()=>{
  const testUri = PLAYLIST_CALM_MAINTAIN;
  if(!selectedDeviceId){ log("まずデバイスを選択→『このデバイスを使う』を押してください"); return; }
  await playPlaylist(testUri);
  log("テスト再生しました");
};
document.getElementById("btnPause").onclick = async ()=>{ await pausePlayback(); log("一時停止しました"); };

// 認可戻りの code があれば自動交換
if(new URLSearchParams(location.search).get("code")) loginSpotify();
</script>
</body>
</html>
